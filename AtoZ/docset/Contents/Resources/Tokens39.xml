<?xml version="1.0" encoding="UTF-8"?>
<Tokens version="1.0">
	<File path="Categories/NSArray+AtoZ.html">
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/cat/NSArray(AtoZ)</TokenIdentifier>
			<Abstract></Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>
			
			<NodeRef refid="39"/>
		</Token>
		
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/arrayWithInts:</TokenIdentifier>
			<Abstract>* Returns an NSArray containing a number of NSNumber elements that have been initialized with NSInteger values. As this method takes a variadic argument list you have to terminate the input with a NSNotFound entry This is done automatically via the $ints(...) macro</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>+ (NSArray *)arrayWithInts:(NSInteger)i, ...</Declaration>
			
			
			<Anchor>//api/name/arrayWithInts:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/arrayWithDoubles:</TokenIdentifier>
			<Abstract>* Returns an NSArray containing a number of NSNumber elements that have been initialized with double values. As this method takes a variadic argument list you have to terminate the input with a FLOAT_MAX entry This is done automatically via the $doubles(...) macro</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>+ (NSArray *)arrayWithDoubles:(double)d, ...</Declaration>
			
			
			<Anchor>//api/name/arrayWithDoubles:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/setSet:</TokenIdentifier>
			<Abstract>* Returns an NSSet containing the same elements as the array (unique of course, as the set does not keep doubled entries)</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>@property (readonly) NSSet *set</Declaration>
			
			
			<Anchor>//api/name/set</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfp/NSArray(AtoZ)/set</TokenIdentifier>
			<Abstract>* Returns an NSSet containing the same elements as the array (unique of course, as the set does not keep doubled entries)</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>@property (readonly) NSSet *set</Declaration>
			
			
			<Anchor>//api/name/set</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/arrayWithKey:</TokenIdentifier>
			<Abstract>* Returns an array of the same size as the original one with the result of calling the keyPath on each object</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (NSArray *)arrayWithKey:(NSString *)keyPath</Declaration>
			
			
			<Anchor>//api/name/arrayWithKey:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/arrayUsingBlock:</TokenIdentifier>
			<Abstract>* Returns an array of the same size as the original one with the results of performing the block on each object</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (NSArray *)arrayUsingBlock:(id ( ^ ) ( id obj ))block</Declaration>
			
			
			<Anchor>//api/name/arrayUsingBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/map:</TokenIdentifier>
			<Abstract>* Shortcut for the arrayUsingBlock method map is better known in more functional oriented languages</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (NSArray *)map:(id ( ^ ) ( id obj ))block</Declaration>
			
			
			<Anchor>//api/name/map:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/reduce:</TokenIdentifier>
			<Abstract>* performs consecutive calls of block for every pair of elements in this array</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (id)reduce:(id ( ^ ) ( id a , id b ))block</Declaration>
			
			
			<Anchor>//api/name/reduce:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/arrayWithoutObject:</TokenIdentifier>
			<Abstract>* Returns a subArray that does not contain the argument object</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (NSArray *)arrayWithoutObject:(id)object</Declaration>
			
			
			<Anchor>//api/name/arrayWithoutObject:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/arrayWithoutObjects:</TokenIdentifier>
			<Abstract>* Returns a subArray that does not contain any of the passed arguments</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (NSArray *)arrayWithoutObjects:(id)object, ...</Declaration>
			
			
			<Anchor>//api/name/arrayWithoutObjects:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/arrayWithoutArray:</TokenIdentifier>
			<Abstract>* Returns a subArray that does not contain any value that the passed NSArray contains</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (NSArray *)arrayWithoutArray:(NSArray *)value</Declaration>
			
			
			<Anchor>//api/name/arrayWithoutArray:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/arrayWithoutSet:</TokenIdentifier>
			<Abstract>* Returns a subArray that does not contain any value that the passed NSSet contains</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (NSArray *)arrayWithoutSet:(NSSet *)values</Declaration>
			
			
			<Anchor>//api/name/arrayWithoutSet:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/filter:</TokenIdentifier>
			<Abstract>* Returns a subArray in wich all object returned true for the block Reduced version of filteredArrayUsingBlock, without the dictionary</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (NSArray *)filter:(BOOL ( ^ ) ( id object ))block</Declaration>
			
			
			<Anchor>//api/name/filter:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/filterOne:</TokenIdentifier>
			<Abstract>* Filters one element from the array that returns YES from the called block might not always be the same, it just will return any match! In case you are not absolutely sure that there is only ONE match better use filter and grab the result manually will return nil for no match</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (id)filterOne:(BOOL ( ^ ) ( id object ))block</Declaration>
			
			
			<Anchor>//api/name/filterOne:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/allKindOfClass:</TokenIdentifier>
			<Abstract>* Returns YES when all members of the current array pass the isKindOfClass test with the given Class</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (BOOL)allKindOfClass:(Class)aClass</Declaration>
			
			
			<Anchor>//api/name/allKindOfClass:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/elementsOfClass:</TokenIdentifier>
			<Abstract>* Returns a subArray with all members of the original array that pass the isKindOfClass test with the given Class</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (NSArray *)elementsOfClass:(Class)aClass</Declaration>
			
			
			<Anchor>//api/name/elementsOfClass:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/setNumbers:</TokenIdentifier>
			<Abstract>* Shortcut for elementsOfClass:NSNumber.class</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>@property (readonly) NSArray *numbers</Declaration>
			
			
			<Anchor>//api/name/numbers</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfp/NSArray(AtoZ)/numbers</TokenIdentifier>
			<Abstract>* Shortcut for elementsOfClass:NSNumber.class</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>@property (readonly) NSArray *numbers</Declaration>
			
			
			<Anchor>//api/name/numbers</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/setStrings:</TokenIdentifier>
			<Abstract>* Shortcut for elementsOfClass:NSString.class</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>@property (readonly) NSArray *strings</Declaration>
			
			
			<Anchor>//api/name/strings</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfp/NSArray(AtoZ)/strings</TokenIdentifier>
			<Abstract>* Shortcut for elementsOfClass:NSString.class</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>@property (readonly) NSArray *strings</Declaration>
			
			
			<Anchor>//api/name/strings</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/setTrimmedStrings:</TokenIdentifier>
			<Abstract>* Returns a subArray with all NSString members and calls trim on each before returning</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>@property (readonly) NSArray *trimmedStrings</Declaration>
			
			
			<Anchor>//api/name/trimmedStrings</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfp/NSArray(AtoZ)/trimmedStrings</TokenIdentifier>
			<Abstract>* Returns a subArray with all NSString members and calls trim on each before returning</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>@property (readonly) NSArray *trimmedStrings</Declaration>
			
			
			<Anchor>//api/name/trimmedStrings</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/setRandomElement:</TokenIdentifier>
			<Abstract>* Returns a random element from this array</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>@property (readonly) id randomElement</Declaration>
			
			
			<Anchor>//api/name/randomElement</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfp/NSArray(AtoZ)/randomElement</TokenIdentifier>
			<Abstract>* Returns a random element from this array</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>@property (readonly) id randomElement</Declaration>
			
			
			<Anchor>//api/name/randomElement</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/randomSubarrayWithSize:</TokenIdentifier>
			<Abstract>* Returns a random subArray of this array with up to 'size' elements</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (NSArray *)randomSubarrayWithSize:(NSUInteger)size</Declaration>
			
			
			<Anchor>//api/name/randomSubarrayWithSize:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/setShuffeled:</TokenIdentifier>
			<Abstract>* Returns a shuffeled version of this array</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>@property (readonly) NSArray *shuffeled</Declaration>
			
			
			<Anchor>//api/name/shuffeled</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfp/NSArray(AtoZ)/shuffeled</TokenIdentifier>
			<Abstract>* Returns a shuffeled version of this array</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>@property (readonly) NSArray *shuffeled</Declaration>
			
			
			<Anchor>//api/name/shuffeled</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/objectAtNormalizedIndex:</TokenIdentifier>
			<Abstract>* A failsave version of objectAtIndex When the given index is outside the bounds of the array it will be projected onto the bounds of the array Just imagine the array to be a ring  that will have its first and last element connected to each other</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (id)objectAtNormalizedIndex:(NSInteger)index</Declaration>
			
			
			<Anchor>//api/name/objectAtNormalizedIndex:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/objectAtIndex:fallback:</TokenIdentifier>
			<Abstract>* A failsave version of objectAtIndex that will return the fallback value in case an error occurrs or the value is nil</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (id)objectAtIndex:(NSUInteger)index fallback:(id)fallback</Declaration>
			
			
			<Anchor>//api/name/objectAtIndex:fallback:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/objectOrNilAtIndex:</TokenIdentifier>
			<Abstract>* Will at least return nil in case the index does not fit the array</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (id)objectOrNilAtIndex:(NSUInteger)index</Declaration>
			
			
			<Anchor>//api/name/objectOrNilAtIndex:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/containsAny:</TokenIdentifier>
			<Abstract>* Returns YES when this array contains any of the elements in enumerable</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (BOOL)containsAny:(id&lt;NSFastEnumeration&gt;)enumerable</Declaration>
			
			
			<Anchor>//api/name/containsAny:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/containsAll:</TokenIdentifier>
			<Abstract>* Returns YES when this array contains all of the elements in enumerable</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (BOOL)containsAll:(id&lt;NSFastEnumeration&gt;)enumerable</Declaration>
			
			
			<Anchor>//api/name/containsAll:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/andExecuteEnumeratorBlock</TokenIdentifier>
			<Abstract>* dummy, just for the 'foreach' macro</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (id)andExecuteEnumeratorBlock</Declaration>
			
			
			<Anchor>//api/name/andExecuteEnumeratorBlock</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/setAndExecuteEnumeratorBlock:</TokenIdentifier>
			<Abstract>* Just a case study at the moment. Just another way of writing enumerateUsingBlock, but as it's written kvc conform the foreach macro can be used to write code like foreach (id o, array) {   ... }</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (void)setAndExecuteEnumeratorBlock:(void ( ^ ) ( id obj , NSUInteger idx , BOOL *stop ))block</Declaration>
			
			
			<Anchor>//api/name/setAndExecuteEnumeratorBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/objectsWithFormat:</TokenIdentifier>
			<Abstract>*</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (NSArray *)objectsWithFormat:(NSString *)format, ...</Declaration>
			
			
			<Anchor>//api/name/objectsWithFormat:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/firstObject</TokenIdentifier>
			<Abstract>Convenience Method to return the first object in
a NSArray</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (id)firstObject</Declaration>
			
			
			<Anchor>//api/name/firstObject</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/az_each:</TokenIdentifier>
			<Abstract>Iterates over all the objects in an array and calls the block on each object</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (void)az_each:(void ( ^ ) ( id obj , NSUInteger index , BOOL *stop ))block</Declaration>
			<Parameters>
				<Parameter>
					<Name>obj</Name>
					<Abstract>(Block Parameter) this is the object in the array currently being enumerated over</Abstract>
				</Parameter><Parameter>
					<Name>index</Name>
					<Abstract>(Block Parameter) this is the index of obj in the array</Abstract>
				</Parameter><Parameter>
					<Name>stop</Name>
					<Abstract>(Block Parameter) set this to YES to stop enumeration, otherwise there is no need to use this</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/az_each:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/az_eachConcurrentlyWithBlock:</TokenIdentifier>
			<Abstract>Enumerates over the receiving arrays objects concurrently in a synchronous method.</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (void)az_eachConcurrentlyWithBlock:(void ( ^ ) ( NSInteger index , id obj , BOOL *stop ))block</Declaration>
			<Parameters>
				<Parameter>
					<Name>index</Name>
					<Abstract>(Block Parameter) the position of the object in the array</Abstract>
				</Parameter><Parameter>
					<Name>obj</Name>
					<Abstract>(Block Parameter) the object being enumerated over</Abstract>
				</Parameter><Parameter>
					<Name>stop</Name>
					<Abstract>(Block Parameter) if you need to stop the enumeration set this to YES otherwise do nothing</Abstract>
				</Parameter>
			</Parameters>
			
			<Anchor>//api/name/az_eachConcurrentlyWithBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/findWithBlock:</TokenIdentifier>
			<Abstract>Finds the first instance of the object that you indicate
via a block (returning a bool) you are looking for</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (id)findWithBlock:(BOOL ( ^ ) ( id obj ))block</Declaration>
			
			
			<Anchor>//api/name/findWithBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/isObjectInArrayWithBlock:</TokenIdentifier>
			<Abstract>Exactly like findWithBlock except it returns a BOOL</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isObjectInArrayWithBlock:(BOOL ( ^ ) ( id obj ))block</Declaration>
			
			
			<Anchor>//api/name/isObjectInArrayWithBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/findAllWithBlock:</TokenIdentifier>
			<Abstract>Like find but instead of returning the first object
that passes the test it returns all objects passing the
bool block test</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (NSArray *)findAllWithBlock:(BOOL ( ^ ) ( id obj ))block</Declaration>
			
			
			<Anchor>//api/name/findAllWithBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/findAllIntoWeakRefsWithBlock:</TokenIdentifier>
			<Abstract>experimental method
like find but instead uses NSHashTable to store weak pointers to
all objects passing the test of the bool block</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (NSHashTable *)findAllIntoWeakRefsWithBlock:(BOOL ( ^ ) ( id ))block</Declaration>
			
			
			<Anchor>//api/name/findAllIntoWeakRefsWithBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/intfm/NSArray(AtoZ)/mapArray:</TokenIdentifier>
			<Abstract>mapArray basically maps an array by enumerating
over the array to be mapped and executes the block while
passing in the object to map. You simply need to either
(1) return the object to be mapped in the new array or
(2) return nil if you don't want to map the passed in object</Abstract>
			<DeclaredIn>NSArray+AtoZ.h</DeclaredIn>			
			
			<Declaration>- (NSArray *)mapArray:(id ( ^ ) ( id obj ))block</Declaration>
			<Parameters>
				<Parameter>
					<Name>block</Name>
					<Abstract>a block in which you return an object to be mapped to a new array or nil to not map it</Abstract>
				</Parameter>
			</Parameters>
			<ReturnValue><Abstract>a new mapped array</Abstract></ReturnValue>
			<Anchor>//api/name/mapArray:</Anchor>
		</Token>
		
	</File>
</Tokens>